// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto2";

/*
 * nanopb compile script:
python $NANOPB_DIR/generator/nanopb_generator.py tactile_data.proto
$NANOPB_DIR/generator-bin/protoc tactile_data.proto --nanopb_out=-v:.
 * For commonjs
protoc --proto_path=. --js_out=import_style=commonjs,binary:./ tactile_data.proto
 * For closurejs
protoc --proto_path=. --js_out=library=tactile_data_pb_lib,binary:.
tactile_data.proto
*/
package audio_to_tactile;

option java_multiple_files = true;
option jspb_use_correct_proto2_semantics = true;

// Based on the web bluetooth MTU throughput test, best result is obtained when
// the size of ptoto message is smaller than 495 bytes.

message AnalogMicInputConfig {
  // replace placeholder with the actual control options.
  optional int32 placeholder = 1;
}

message PdmMicInputConfig {
  // replace placeholder with the actual control options.
  optional int32 placeholder = 1;
}

message InputConfiguration {
  oneof type {
    AnalogMicInputConfig analog_mic_config = 1;
    PdmMicInputConfig pdm_mic_config = 2;
    // add other configs for input here.
  }
}

message PassThroughProcessConfig {
  // replace placeholder with the actual control options.
  optional int32 placeholder = 1;
}

message AudioToTactileProcessConfig {
  // replace placeholder with the actual control options.
  optional int32 placeholder = 1;
}

message ProcessConfiguration {
  oneof type {
    PassThroughProcessConfig pass_through_config = 1;
    AudioToTactileProcessConfig audio_to_tactile_config = 2;
  }
}

message SerialOutputConfig {
  // replace placeholder with the actual control options.
  optional int32 placeholder = 1;
}

message TactorsOutputConfig {
  // replace placeholder with the actual control options.
  optional int32 placeholder = 1;
}

message OutputConfiguration {
  oneof type {
    SerialOutputConfig serial_config = 1;
    TactorsOutputConfig tactors_output_config = 2;
  }
}

message OperationMode {
  enum InputOption {
    ANALOG_EXTERNAL_MIC = 0;
    PDM_MIC = 1;
    SERIAL_PER_CHANNEL_WAVEFORM = 2;
    SERIAL_FM_GENERATED_WAVEFORM = 3;
    INTERNAL_WAVE_GENERATOR = 4;
    BLE_AUDIO = 5;
    // Probably not a very good idea to have this given the BLE throughput test
    // and we already have the awesome fm generated waveform. Also, when the
    // number of tactors is different, configuring the size of message is
    // tricky.
    BLE_PER_CHANNEL_WAVEFORM = 6;
    BLE_FM_GENERATED_WAVEFORM = 7;
  }

  enum ProcessOption {
    PASS_THROUGH = 0;
    AUDIO_TO_TACTILE = 1;
  }

  enum OutputOption {
    SERIAL = 0;
    TACTORS = 1;
  }
  // Required.
  optional InputOption input = 1;
  // Required.
  optional ProcessOption process = 2;
  // Required.
  optional OutputOption output = 3;
}

message OperationConfig {
  // Optional, when not provided, with default in firmware.
  optional InputConfiguration input_config = 1;
  // Optional, when not provided, with default in firmware.
  optional ProcessConfiguration process_config = 2;
  // Optional, when not provided, with default in firmware.
  optional OutputConfiguration output_config = 3;
}

message TactorAmplitudes {
  repeated float tactor_amplitudes = 1;
}

message TactorPhases {
  repeated float tactor_phases = 1;
}

message TactorFrequencies {
  repeated float tactor_frequencies = 1;
}

message SupportedOperationModes {
  repeated OperationMode supported_operation_modes = 1;
}

message Tactor {
  optional float x = 1;
  optional float y = 2;
  optional string note = 3;
}

message TactorHardwareLayout {
  repeated Tactor tactors = 1;
}

message GetResponse {
  oneof type {
    TactorHardwareLayout tactor_hardware_layout_response = 1;
    float battery_response = 2;
    SupportedOperationModes supported_operation_modes_response = 3;
    OperationMode current_operation_mode_response = 4;
    bool operation_is_running_response = 5;
    int32 output_gain_response = 6;
    int32 denoising_response = 7;
    int32 compression_response = 8;
    TactorAmplitudes tactor_amplitudes_response = 9;
    TactorPhases tactor_phases_response = 10;
    TactorFrequencies tactor_frequencies_response = 11;
  }
}

message TimeSyncPing {
  // Required
  optional float client_start_time_sync_time = 1;
  // Required
  optional float tactile_receive_time = 2;
  // Required
  optional float tactile_send_ping_time = 3;
}

message TimeSyncPong {
  // Required
  optional float client_start_time_sync_time = 1;
  // Required
  optional float tactile_receive_time = 2;
  // Required
  optional float tactile_send_ping_time = 3;
  // Required
  optional float client_receive_ping_time = 4;
  // Required
  optional float client_send_pong_time = 5;
}

message TactileMessage {
  oneof type {
    GetResponse get_response = 1;
    int32 battery_status = 2;
    // For debugging and messages
    string message = 3;
    TimeSyncPing time_sync_ping = 4;
  }
}

message GetRequest {
  enum GetOpion {
    TACTOR_HARDWARE_LAYOUT = 0;
    BATTERY = 1;
    SUPPORTED_OPERATION_MODES = 2;
    CURRENT_OPERATION_MODE = 3;
    OPERATION_IS_RUNNING = 4;
    OUTPUT_GAIN = 5;
    DENOISING = 6;
    COMPRESSION = 7;
    TACTOR_AMPLITUDES = 8;
    TACTOR_PHASES = 9;
    TACTOR_FREQUENCIES = 10;
  }
  // required
  optional GetOpion option = 1;
}

message SetRequest {
  oneof type {
    OperationMode operation_mode_request = 1;
    OperationConfig operation_config_request = 2;
    bool operation_run_request = 3;
    int32 output_gain_request = 4;
    int32 denoising_request = 5;
    int32 compression_request = 6;
    TactorAmplitudes tactor_amplitudes_request = 7;
    TactorPhases tactor_phases_request = 8;
    TactorFrequencies tactor_frequencies_request = 9;
  }
}

message StartTimeSyncRequest {
  // Required
  optional float send_time = 1;
}

message ClientMessage {
  oneof type {
    GetRequest get_request = 1;
    SetRequest set_request = 2;
    bytes ble_audio = 3;
    bytes ble_fm_generated_waveform = 4;
    // A very small packet for warming up. The value does not matter.
    bool warm_up = 5;
    StartTimeSyncRequest start_time_sync_request = 6;
    TimeSyncPong time_sync_pong = 7;
  }
}
